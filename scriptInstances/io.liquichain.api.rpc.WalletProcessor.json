{
  "code" : "io.liquichain.api.rpc.WalletProcessor",
  "inputs" : [ ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.rpc;\n\nimport static io.liquichain.api.rpc.EthApiConstants.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.meveo.admin.exception.BusinessException;\nimport org.meveo.api.exception.EntityDoesNotExistsException;\nimport org.meveo.model.customEntities.LiquichainApp;\nimport org.meveo.model.customEntities.VerifiedEmail;\nimport org.meveo.model.customEntities.VerifiedPhoneNumber;\nimport org.meveo.model.customEntities.Wallet;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.web3j.crypto.*;\n\nimport io.liquichain.api.rpc.BlockchainProcessor;\n\npublic class WalletProcessor extends BlockchainProcessor {\n    private static final Logger LOG = LoggerFactory.getLogger(WalletProcessor.class);\n    public static final List<String> WALLET_METHODS = Arrays.asList(\"wallet_creation\", \"wallet_update\", \"wallet_info\",\n                                                                    \"wallet_report\");\n    private String APP_NAME = config.getProperty(\"eth.api.appname\", \"licoin\");\n\n    @Override\n    public void execute(Map<String, Object> parameters) throws BusinessException {\n        String method = \"\" + parameters.get(\"method\");\n        LOG.info(\"json rpc: {}, parameters:{}\", method, parameters);\n        String requestId = \"\" + parameters.get(\"id\");\n        switch (method) {\n            case \"wallet_creation\":\n                result = createWallet(requestId, parameters);\n                break;\n            case \"wallet_update\":\n                result = updateWallet(requestId, parameters);\n                break;\n            case \"wallet_info\":\n                result = getWalletInfo(requestId, parameters);\n                break;\n            case \"wallet_report\":\n                result = createResponse(requestId, \"wallet reported\");\n                break;\n            default:\n                result = createErrorResponse(requestId, METHOD_NOT_FOUND, NOT_IMPLEMENTED_ERROR);\n                break;\n        }\n    }\n\n    private String createWallet(String requestId, Map<String, Object> parameters) {\n        List<String> params = (ArrayList<String>) parameters.get(\"params\");\n        String name = params.get(0);\n        String walletHash = retrieveHash(params, 1);\n        String accountHash = retrieveHash(params, 2);\n        String publicInfo = params.get(3);\n        String privateInfo = null;\n        if (params.size() > 4) {\n            privateInfo = params.get(4);\n        }\n        Wallet wallet = null;\n        LiquichainApp app = null;\n\n        // check existing Wallet\n        try {\n            wallet = crossStorageApi.find(defaultRepo, walletHash, Wallet.class);\n            if (wallet != null) {\n                return createErrorResponse(requestId, INVALID_REQUEST, WALLET_EXISTS_ERROR);\n            }\n        } catch (EntityDoesNotExistsException e) {\n            // do nothing, we expect wallet to not exist\n        }\n\n        wallet = new Wallet();\n\n        try {\n            app = crossStorageApi\n                    .find(defaultRepo, LiquichainApp.class)\n                    .by(\"name\", APP_NAME)\n                    .getResult();\n            if (app == null) {\n                return createErrorResponse(requestId, INTERNAL_ERROR, UNKNOWN_APPLICATION_ERROR);\n            }\n        } catch (Exception e) {\n            LOG.error(UNKNOWN_APPLICATION_ERROR + \": \" + APP_NAME, e);\n            return createErrorResponse(requestId, INTERNAL_ERROR, UNKNOWN_APPLICATION_ERROR);\n        }\n\n        String emailAddress = null;\n        String phoneNumber = null;\n        if (privateInfo != null) {\n            Map<String, String> privateInfoMap = new Gson()\n                    .fromJson(privateInfo, new TypeToken<Map<String, String>>() {}.getType());\n            emailAddress = privateInfoMap.get(\"emailAddress\");\n            phoneNumber = privateInfoMap.get(\"phoneNumber\");\n        }\n\n\n        try {\n            // name = validateName(name);\n            // emailAddress = validateEmail(emailAddress, walletHash);\n            phoneNumber = validatePhoneNumber(phoneNumber, walletHash);\n        } catch (BusinessException e) {\n            LOG.error(INVALID_REQUEST, e);\n            return createErrorResponse(requestId, INVALID_REQUEST, e.getMessage());\n        }\n\n        try {\n            LOG.info(\n                    \"Creating wallet with name={}, walletHash={}, accountHash={}, email={}, phoneNumber={}\",\n                    name, walletHash, accountHash, emailAddress, phoneNumber);\n            wallet.setUuid(walletHash);\n            wallet.setName(name);\n            wallet.setAccountHash(accountHash);\n            wallet.setPublicInfo(publicInfo);\n            wallet.setBalance(\"0\");\n            wallet.setApplication(app);\n            wallet.setVerified(false);\n\n            if (emailAddress != null) {\n                VerifiedEmail verifiedEmail = new VerifiedEmail();\n                verifiedEmail.setUuid(DigestUtils.sha1Hex(emailAddress));\n                verifiedEmail.setEmail(emailAddress);\n                verifiedEmail.setWalletId(walletHash);\n                verifiedEmail.setVerified(false);\n                crossStorageApi.createOrUpdate(defaultRepo, verifiedEmail);\n                wallet.setEmailAddress(verifiedEmail);\n            }\n\n            if (phoneNumber != null) {\n                VerifiedPhoneNumber verifiedPhoneNumber = new VerifiedPhoneNumber();\n                verifiedPhoneNumber.setUuid(DigestUtils.sha1Hex(phoneNumber));\n                verifiedPhoneNumber.setPhoneNumber(phoneNumber);\n                verifiedPhoneNumber.setWalletId(walletHash);\n                verifiedPhoneNumber.setVerified(false);\n                crossStorageApi.createOrUpdate(defaultRepo, verifiedPhoneNumber);\n                wallet.setPhoneNumber(verifiedPhoneNumber);\n            }\n\n            String newHash = crossStorageApi.createOrUpdate(defaultRepo, wallet);\n            if (newHash != walletHash) {\n                LOG.info(\"Wallet hash changed from {} to {}\", walletHash, newHash);\n                wallet.setUuid(walletHash);\n                LOG.info(\"Attempt to update wallet with hash: {}\", walletHash);\n                newHash = crossStorageApi.createOrUpdate(defaultRepo, wallet);\n                LOG.info(\"Updated wallet hash: {}\", newHash);\n            }\n            return createResponse(requestId, walletHash);\n        } catch (Exception e) {\n            LOG.error(CREATE_WALLET_ERROR, e);\n            return createErrorResponse(requestId, TRANSACTION_REJECTED, CREATE_WALLET_ERROR);\n        }\n    }\n\n    private String updateWallet(String requestId, Map<String, Object> parameters) {\n        LOG.info(\"PARAMETERS: {}\", parameters);\n        List<String> params = (ArrayList<String>) parameters.get(\"params\");\n        String name = params.get(0);\n        String walletHash = retrieveHash(params, 1);\n        String signature = params.get(2);\n        String publicInfo = params.get(3);\n        String privateInfo = null;\n        if (params.size() > 4) {\n            privateInfo = params.get(4);\n        }\n\n        String validatedAddress = \"\";\n\n        try {\n            validatedAddress = parseAddress(signature, new Gson().toJson(publicInfo));\n        } catch (Exception e) {\n            LOG.error(INVALID_REQUEST, e);\n            return createErrorResponse(requestId, INVALID_REQUEST, e.getMessage());\n        }\n        boolean sameAddress = walletHash.toLowerCase().equals(validatedAddress);\n        LOG.info(\"validated address: {}, walletHash: {}, same address: {}\", validatedAddress,\n                 walletHash.toLowerCase(), sameAddress);\n\n        if(!sameAddress) {\n            return createErrorResponse(requestId, INVALID_REQUEST, INVALID_SIGNATURE_ERROR);\n        }\n\n        Wallet wallet = null;\n\n        try {\n            wallet = crossStorageApi.find(defaultRepo, walletHash, Wallet.class);\n            if (wallet == null) {\n                return createErrorResponse(requestId, INVALID_REQUEST, UNKNOWN_WALLET_ERROR);\n            }\n        } catch (EntityDoesNotExistsException e) {\n            LOG.error(UNKNOWN_WALLET_ERROR, e);\n            return createErrorResponse(requestId, INVALID_REQUEST, UNKNOWN_WALLET_ERROR);\n        }\n\n        String emailAddress = null;\n        String phoneNumber = null;\n        if (privateInfo != null) {\n            Map<String, String> privateInfoMap = new Gson()\n                    .fromJson(privateInfo, new TypeToken<Map<String, String>>() {}.getType());\n            emailAddress = privateInfoMap.get(\"emailAddress\");\n            phoneNumber = privateInfoMap.get(\"phoneNumber\");\n        }\n\n        LOG.info(\"received email: {}\", emailAddress);\n        LOG.info(\"received phoneNumber: {}\", phoneNumber);\n\n        VerifiedEmail verifiedEmail = wallet.getEmailAddress();\n        VerifiedPhoneNumber verifiedPhoneNumber = wallet.getPhoneNumber();\n        String existingEmail;\n        String existingPhoneNumber;\n        try {\n            // if (!wallet.getName().equals(name)) {\n            // name = validateName(name);\n            // }\n\n            if (verifiedEmail != null) {\n                LOG.info(\"Verified email: {}\", verifiedEmail.getUuid());\n                VerifiedEmail oldEmail = findEntity(verifiedEmail.getUuid(), VerifiedEmail.class);\n                if (oldEmail != null) {\n                    existingEmail = oldEmail.getEmail();\n                } else {\n                    existingEmail = null;\n                }\n                LOG.info(\"existing email: {}\", existingEmail);\n                if (emailAddress != null && existingEmail != null && !existingEmail.equals(emailAddress)) {\n                    // emailAddress = validateEmail(emailAddress, walletHash);\n                    verifiedEmail = new VerifiedEmail();\n                    verifiedEmail.setUuid(DigestUtils.sha1Hex(emailAddress));\n                    verifiedEmail.setEmail(emailAddress);\n                    verifiedEmail.setWalletId(wallet.getUuid());\n                    verifiedEmail.setVerified(false);\n                    crossStorageApi.createOrUpdate(defaultRepo, verifiedEmail);\n                    LOG.info(\"old email: {}, saved email: {}\", existingEmail, emailAddress);\n                }\n            } else if (emailAddress != null) {\n                // emailAddress = validateEmail(emailAddress, walletHash);\n                verifiedEmail = new VerifiedEmail();\n                verifiedEmail.setUuid(DigestUtils.sha1Hex(emailAddress));\n                verifiedEmail.setEmail(emailAddress);\n                verifiedEmail.setWalletId(wallet.getUuid());\n                verifiedEmail.setVerified(false);\n                crossStorageApi.createOrUpdate(defaultRepo, verifiedEmail);\n                LOG.info(\"No old email, saved email: {}\", emailAddress);\n            }\n\n            if (verifiedPhoneNumber != null) {\n                LOG.info(\"Verified phoneNumber: {}\", verifiedPhoneNumber.getUuid());\n                VerifiedPhoneNumber oldPhoneNumber =\n                        findEntity(verifiedPhoneNumber.getUuid(), VerifiedPhoneNumber.class);\n                if (oldPhoneNumber != null) {\n                    existingPhoneNumber = oldPhoneNumber.getPhoneNumber();\n                } else {\n                    existingPhoneNumber = null;\n                }\n                LOG.info(\"existing phoneNumber: {}\", existingPhoneNumber);\n                if (existingPhoneNumber != null && !existingPhoneNumber.equals(phoneNumber)) {\n                    phoneNumber = validatePhoneNumber(phoneNumber, walletHash);\n                    verifiedPhoneNumber = new VerifiedPhoneNumber();\n                    verifiedPhoneNumber.setUuid(DigestUtils.sha1Hex(phoneNumber));\n                    verifiedPhoneNumber.setPhoneNumber(phoneNumber);\n                    verifiedPhoneNumber.setWalletId(wallet.getUuid());\n                    verifiedPhoneNumber.setVerified(false);\n                    crossStorageApi.createOrUpdate(defaultRepo, verifiedPhoneNumber);\n                }\n            } else if (phoneNumber != null) {\n                phoneNumber = validatePhoneNumber(phoneNumber, walletHash);\n                verifiedPhoneNumber = new VerifiedPhoneNumber();\n                verifiedPhoneNumber.setUuid(DigestUtils.sha1Hex(phoneNumber));\n                verifiedPhoneNumber.setPhoneNumber(phoneNumber);\n                verifiedPhoneNumber.setWalletId(wallet.getUuid());\n                verifiedPhoneNumber.setVerified(false);\n                crossStorageApi.createOrUpdate(defaultRepo, verifiedPhoneNumber);\n            }\n        } catch (Exception e) {\n            LOG.error(INVALID_REQUEST, e);\n            return createErrorResponse(requestId, INVALID_REQUEST, e.getMessage());\n        }\n\n        try {\n            wallet.setName(name);\n            wallet.setPublicInfo(publicInfo);\n            if (verifiedEmail != null) {\n                wallet.setEmailAddress(verifiedEmail);\n            }\n            if (verifiedPhoneNumber != null) {\n                wallet.setPhoneNumber(verifiedPhoneNumber);\n            }\n\n            crossStorageApi.createOrUpdate(defaultRepo, wallet);\n            return createResponse(requestId, name);\n        } catch (Exception e) {\n            LOG.error(UPDATE_WALLET_ERROR, e);\n            return createErrorResponse(requestId, TRANSACTION_REJECTED, UPDATE_WALLET_ERROR);\n        }\n    }\n\n    private String getWalletInfo(String requestId, Map<String, Object> parameters) {\n        List<String> params = (ArrayList<String>) parameters.get(\"params\");\n        String walletHash = retrieveHash(params, 0);\n        String signature = \"\";\n        String message = \"\";\n\n        if (params.size() > 1) {\n            signature = params.get(1);\n        }\n        if (params.size() > 2) {\n            message = params.get(2);\n        }\n\n        Wallet wallet = null;\n\n        try {\n            wallet = crossStorageApi.find(defaultRepo, walletHash, Wallet.class);\n            if (wallet == null) {\n                return createErrorResponse(requestId, INVALID_REQUEST, UNKNOWN_WALLET_ERROR);\n            }\n        } catch (EntityDoesNotExistsException e) {\n            LOG.error(UNKNOWN_WALLET_ERROR, e);\n            return createErrorResponse(requestId, INVALID_REQUEST, UNKNOWN_WALLET_ERROR);\n        }\n\n        boolean shouldValidate = signature != null && !signature.isEmpty()\n                && message != null && !message.isEmpty();\n        boolean isValidSignature = false;\n        Long requestTime = 0L;\n        if (shouldValidate) {\n            String validatedAddress = \"\";\n            try {\n                validatedAddress = parseAddress(signature, message);\n            } catch (Exception e) {\n                LOG.error(INVALID_REQUEST, e);\n                return createErrorResponse(requestId, INVALID_REQUEST, e.getMessage());\n            }\n            boolean sameAddress = walletHash.toLowerCase().equals(validatedAddress);\n            LOG.info(\"validated address: {}, walletHash: {}, same address: {}\", validatedAddress,\n                     walletHash.toLowerCase(), sameAddress);\n            Long lastRequest = wallet.getLastPrivateInfoRequest();\n            if (lastRequest == null) {\n                lastRequest = 0L;\n            }\n            requestTime = Long.parseLong(message.split(\",\")[2]);\n            LOG.info(\"lastRequest={}\", lastRequest);\n            LOG.info(\"requestTime={}\", requestTime);\n\n            isValidSignature = sameAddress && requestTime > lastRequest;\n            LOG.info(\"isValidSignature={}\", isValidSignature);\n        }\n\n        StringBuilder response = new StringBuilder()\n                .append(\"{\")\n                .append(String.format(\"\\\"name\\\":\\\"%s\\\",\", wallet.getName()))\n                .append(String.format(\"\\\"publicInfo\\\":%s\",\n                                      new Gson().toJson(wallet.getPublicInfo())));\n        if (isValidSignature) {\n            StringBuilder privateInfo = new StringBuilder(\"{\");\n            VerifiedEmail verifiedEmail = wallet.getEmailAddress();\n            LOG.info(\"verifiedEmail={}\", verifiedEmail);\n            if (verifiedEmail != null) {\n                String emailId = verifiedEmail.getUuid();\n                LOG.info(\"emailId={}\", emailId);\n                String emailAddress = verifiedEmail.getEmail();\n                boolean hasEmailAddress = emailAddress != null && !emailAddress.isEmpty();\n                if (emailId != null && !hasEmailAddress) {\n                    try {\n                        verifiedEmail =\n                                crossStorageApi.find(defaultRepo, emailId, VerifiedEmail.class);\n                        if (verifiedEmail != null) {\n                            emailAddress = verifiedEmail.getEmail();\n                        }\n                    } catch (Exception e) {\n                        LOG.error(\"Error retrieving email with uuid: \" + emailId, e);\n                        emailAddress = null;\n                    }\n                }\n                LOG.info(\"emailAddress={}\", emailAddress);\n                if (emailAddress != null && !emailAddress.trim().isEmpty()) {\n                    privateInfo\n                            .append(String.format(\n                                    \"\\\"emailAddress\\\": {\\\"value\\\": \\\"%s\\\", \\\"verified\\\": \\\"%s\\\", \\\"hash\\\": \\\"%s\\\"}\",\n                                    emailAddress, verifiedEmail.getVerified(), verifiedEmail.getUuid()));\n                }\n            }\n\n            VerifiedPhoneNumber verifiedPhoneNumber = wallet.getPhoneNumber();\n            LOG.info(\"verifiedPhoneNumber={}\", verifiedPhoneNumber);\n            if (verifiedPhoneNumber != null) {\n                String phoneId = verifiedPhoneNumber.getUuid();\n                LOG.info(\"phoneId={}\", phoneId);\n                String phoneNumber = verifiedPhoneNumber.getPhoneNumber();\n                boolean hasPhoneNumber = phoneNumber != null && !phoneNumber.isEmpty();\n                if (phoneId != null && !hasPhoneNumber) {\n                    try {\n                        verifiedPhoneNumber =\n                                crossStorageApi.find(defaultRepo, phoneId,\n                                                     VerifiedPhoneNumber.class);\n                        if (verifiedPhoneNumber != null) {\n                            phoneNumber = verifiedPhoneNumber.getPhoneNumber();\n                        }\n                    } catch (Exception e) {\n                        LOG.error(\"Error retrieving phone number with uuid: \" + phoneId, e);\n                        phoneNumber = null;\n                    }\n                }\n                LOG.info(\"phoneNumber={}\", phoneNumber);\n                if (phoneNumber != null && !phoneNumber.trim().isEmpty()) {\n                    if (response.indexOf(\"emailAddress\") > 0) {\n                        response.append(\",\");\n                    }\n                    privateInfo\n                            .append(String.format(\n                                    \"\\\"phoneNumber\\\": {\\\"value\\\": \\\"%s\\\", \\\"verified\\\": \\\"%s\\\", \\\"hash\\\": \\\"%s\\\"}\",\n                                    phoneNumber, verifiedPhoneNumber.getVerified(), verifiedPhoneNumber.getUuid()));\n                }\n            }\n            privateInfo.append(\"}\");\n            response.append(String.format(\",\\\"privateInfo\\\":%s\",\n                                          new Gson().toJson(privateInfo.toString())));\n            try {\n                wallet.setLastPrivateInfoRequest(requestTime);\n                crossStorageApi.createOrUpdate(defaultRepo, wallet);\n            } catch (Exception e) {\n                LOG.error(\"Error updating wallet last private info request\", e);\n            }\n\n        }\n        response.append(\"}\");\n\n        return createResponse(requestId, response.toString());\n    }\n}\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ ],
  "importScriptInstances" : [ {
    "code" : "io.liquichain.api.rpc.BlockchainProcessor",
    "inputs" : [ ],
    "outputs" : [ {
      "name" : "result",
      "type" : "String"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package io.liquichain.api.rpc;\n\nimport static io.liquichain.api.rpc.EthApiConstants.*;\n\nimport org.meveo.admin.exception.BusinessException;\nimport org.meveo.api.exception.EntityDoesNotExistsException;\nimport org.meveo.api.persistence.CrossStorageApi;\nimport org.meveo.commons.utils.ParamBean;\nimport org.meveo.commons.utils.ParamBeanFactory;\nimport org.meveo.model.customEntities.VerifiedEmail;\nimport org.meveo.model.customEntities.VerifiedPhoneNumber;\nimport org.meveo.model.customEntities.Wallet;\nimport org.meveo.model.storage.Repository;\nimport org.meveo.service.script.Script;\nimport org.meveo.service.storage.RepositoryService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigInteger;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.web3j.crypto.*;\nimport org.web3j.utils.*;\n\npublic class BlockchainProcessor extends Script {\n    private static final Logger LOG = LoggerFactory.getLogger(BlockchainProcessor.class);\n    private static final Map<String, Object[]> TRANSACTION_HOOKS = new HashMap<>();\n\n    private final RepositoryService repositoryService = getCDIBean(RepositoryService.class);\n    private ParamBeanFactory paramBeanFactory = getCDIBean(ParamBeanFactory.class);\n\n    protected final CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\n    protected final Repository defaultRepo = repositoryService.findDefaultRepository();\n    protected ParamBean config = paramBeanFactory.getInstance();\n    protected String result;\n\n    public String getResult() {\n        return this.result;\n    }\n\n    public static boolean addTransactionHook(String regex, Script script) {\n        boolean isHookAdded = true;\n        String key = regex + \":\" + script.getClass().getName();\n        LOG.info(\"addTransactionHook key: {}\", key);\n        isHookAdded = !TRANSACTION_HOOKS.containsKey(key);\n        if (isHookAdded) {\n            Pattern pattern = Pattern.compile(regex);\n            TRANSACTION_HOOKS.put(key, new Object[]{pattern, script});\n        }\n        return isHookAdded;\n    }\n\n    protected void processTransactionHooks(String transactionHash, SignedRawTransaction transaction) {\n        try {\n            String data = new String(new BigInteger(transaction.getData(), 16).toByteArray());\n            LOG.info(\"try matching {} hooks\", TRANSACTION_HOOKS.size());\n            TRANSACTION_HOOKS.forEach((String key, Object[] hook) -> {\n                LOG.info(\"try hook {} on {}\", key, data);\n                Pattern pattern = (Pattern) hook[0];\n                Script script = (Script) hook[1];\n                Matcher matcher = pattern.matcher(data);\n                if (matcher.find()) {\n                    LOG.info(\" hook {} matched\", key);\n                    Map<String, Object> context = new HashMap<>();\n                    context.put(\"transaction\", transaction);\n                    context.put(\"transactionHash\", transactionHash);\n                    context.put(\"matcher\", matcher);\n                    try {\n                        script.execute(context);\n                        if (context.containsKey(\"result\")) {\n                            LOG.info(\" hook result:{} \", context.get(\"result\"));\n                        }\n                    } catch (Exception e) {\n                        LOG.error(\"error while invoking transaction hook {}\", script, e);\n                    }\n                } else {\n                    LOG.info(\" hook {} matched\", key);\n                }\n            });\n            if (data.contains(\"orderId\")) {\n                LOG.info(\"detected orderId:{}\", data);\n            }\n        } catch (Exception ex) {\n            LOG.info(\"error while detecting order:{}\", ex);\n        }\n    }\n\n    protected String createResponse(String requestId, String response) {\n        return EthApiUtils.createResponse(requestId, response);\n    }\n\n    protected String createErrorResponse(String requestId, String errorCode, String message) {\n        return EthApiUtils.createErrorResponse(requestId, errorCode, message);\n    }\n\n    protected String normalizeHash(String hash) {\n        return EthApiUtils.normalizeHash(hash);\n    }\n\n    protected String retrieveHash(List<String> parameters, int parameterIndex) {\n        return normalizeHash(parameters.get(parameterIndex));\n    }\n\n    protected boolean isJSONValid(String json) {\n        return EthApiUtils.isJSONValid(json);\n    }\n\n    protected String toHex(byte[] bytes) {\n        return EthApiUtils.toHex(bytes);\n    }\n\n    protected String toBigHex(String value) {\n        return EthApiUtils.toBigHex(value);\n    }\n\n    protected String validateName(String name) throws BusinessException {\n        if (name == null || name.trim().isEmpty()) {\n            throw new BusinessException(NAME_REQUIRED_ERROR);\n        }\n        Wallet walletWithSameName = null;\n        try {\n            walletWithSameName = crossStorageApi\n                    .find(defaultRepo, Wallet.class)\n                    .by(\"name\", name)\n                    .getResult();\n        } catch (Exception e) {\n            // do nothing, we want wallet name to be unique\n        }\n        if (walletWithSameName != null) {\n            String error = String.format(NAME_EXISTS_ERROR, name);\n            LOG.error(error);\n            throw new BusinessException(error);\n        }\n        return name;\n    }\n\n    protected String validateEmail(String email, String walletId) throws BusinessException {\n        // if (email == null || email.trim().isEmpty()) {\n        // throw new BusinessException(EMAIL_REQUIRED_ERROR);\n        // }\n        if (email != null && !email.trim().isEmpty()) {\n            VerifiedEmail existingEmail = null;\n            try {\n                existingEmail = crossStorageApi\n                        .find(defaultRepo, VerifiedEmail.class)\n                        .by(\"email\", email)\n                        .by(\"not-inList walletId\", Arrays.asList(walletId))\n                        .getResult();\n            } catch (Exception e) {\n                // do nothing, we want email address to be unique\n            }\n            if (existingEmail != null) {\n                String error = String.format(EMAIL_EXISTS_ERROR, email);\n                LOG.error(error);\n                throw new BusinessException(error);\n            }\n        }\n        return email;\n    }\n\n    protected String validatePhoneNumber(String phoneNumber, String walletId)\n            throws BusinessException {\n        if (phoneNumber == null || phoneNumber.trim().isEmpty()) {\n            throw new BusinessException(PHONE_NUMBER_REQUIRED_ERROR);\n        }\n        VerifiedPhoneNumber existingPhoneNumber = null;\n        try {\n            existingPhoneNumber = crossStorageApi\n                    .find(defaultRepo, VerifiedPhoneNumber.class)\n                    .by(\"phoneNumber\", phoneNumber)\n                    .by(\"not-inList walletId\", Arrays.asList(walletId))\n                    .getResult();\n        } catch (Exception e) {\n            // do nothing, we want wallet phoneNumber to be unique\n        }\n        if (existingPhoneNumber != null) {\n            String error = String.format(PHONE_NUMBER_EXISTS_ERROR, phoneNumber);\n            LOG.error(error);\n            throw new BusinessException(error);\n        }\n        return phoneNumber;\n    }\n\n    protected String parseAddress(String signature, String message) throws Exception {\n        byte[] messageHash = Hash.sha3(message.getBytes(StandardCharsets.UTF_8));\n        LOG.info(\"messageHash={}\", Numeric.toHexString(messageHash));\n        String r = signature.substring(0, 66);\n        String s = \"0x\" + signature.substring(66, 130);\n        String v = \"0x\" + signature.substring(130, 132);\n        String publicKey = Sign\n                .signedMessageHashToKey(\n                        messageHash,\n                        new Sign.SignatureData(\n                                Numeric.hexStringToByteArray(v)[0],\n                                Numeric.hexStringToByteArray(r),\n                                Numeric.hexStringToByteArray(s)\n                        )\n                )\n                .toString(16);\n        String address = Keys.getAddress(publicKey);\n        LOG.info(\"address: \" + address);\n        return address;\n    }\n\n    protected <T> T findEntity(String uuid, Class<T> clazz) {\n        T entity = null;\n        try {\n            entity = crossStorageApi.find(defaultRepo, uuid, clazz);\n        } catch (EntityDoesNotExistsException e) {\n            LOG.warn(\"No {} with uuid: {}\", clazz.getSimpleName(), uuid);\n        }\n        return entity;\n    }\n}\n",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ ],
    "importScriptInstances" : [ ]
  } ]
}