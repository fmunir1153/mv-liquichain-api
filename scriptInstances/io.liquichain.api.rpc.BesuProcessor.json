{
  "code" : "io.liquichain.api.rpc.BesuProcessor",
  "inputs" : [ ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.rpc;\n\nimport static io.liquichain.api.rpc.EthApiConstants.*;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.ws.rs.client.*;\nimport javax.ws.rs.core.*;\nimport javax.ws.rs.ext.*;\nimport javax.enterprise.context.ApplicationScoped;\n\nimport org.meveo.admin.exception.BusinessException;\nimport org.meveo.model.customEntities.Transaction;\n\nimport com.google.gson.Gson;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.web3j.crypto.*;\nimport org.web3j.utils.*;\n\nimport io.liquichain.api.rpc.BlockchainProcessor;\n\n@ApplicationScoped\npublic class BesuProcessor extends BlockchainProcessor {\n    private static final Logger LOG = LoggerFactory.getLogger(BesuProcessor.class);\n\n    private String BESU_API_URL = config.getProperty(\"besu.api.url\", \"https://testnet.liquichain.io/rpc\");\n\n    @Override\n    public void execute(Map<String, Object> parameters) throws BusinessException {\n        String method = \"\" + parameters.get(\"method\");\n        LOG.info(\"json rpc: {}, parameters:{}\", method, parameters);\n        String requestId = \"\" + parameters.get(\"id\");\n        switch (method) {\n            case \"get_chainId\":\n                result = createResponse(requestId, \"0x4c\");\n                break;\n            case \"eth_sendRawTransaction\":\n                result = sendRawTransaction(requestId, parameters);\n                break;\n            default:\n                result = callEthJsonRpc(requestId, parameters);\n                break;\n        }\n    }\n\n    private String callProxy(String body) throws IOException, InterruptedException {\n        LOG.info(\"callProxy body={}\", body);\n        LOG.info(\"BESU_API_URL={}\", BESU_API_URL);\n        Client client = ClientBuilder.newClient();\n        String response = client.target(BESU_API_URL)\n                                .request(MediaType.APPLICATION_JSON)\n                                .post(Entity.json(body), String.class);\n        LOG.info(\"callProxy response={}\", response);\n        return response;\n    }\n\n    private String callEthJsonRpc(String requestId, Map<String, Object> parameters) {\n        String requestBody = new StringBuilder()\n                .append(\"{\")\n                .append(String.format(\"\\\"id\\\":%s,\", parameters.get(\"id\")))\n                .append(String.format(\"\\\"jsonrpc\\\":\\\"%s\\\",\", (String) parameters.get(\"jsonrpc\")))\n                .append(String.format(\"\\\"method\\\":\\\"%s\\\",\", (String) parameters.get(\"method\")))\n                .append(String.format(\"\\\"params\\\":%s\", new Gson().toJson(parameters.get(\"params\"))))\n                .append(\"}\")\n                .toString();\n        try {\n            return callProxy(requestBody);\n        } catch (Exception e) {\n            LOG.error(PROXY_REQUEST_ERROR, e);\n            return createErrorResponse(requestId, INTERNAL_ERROR, PROXY_REQUEST_ERROR);\n        }\n    }\n\n    private String sendRawTransaction(String requestId, Map<String, Object> parameters) {\n        result = callEthJsonRpc(requestId, parameters);\n        boolean hasError = result.contains(\"\\\"error\\\"\");\n        if (hasError) {\n            return result;\n        }\n        List<String> params = (List<String>) parameters.get(\"params\");\n        String data = (String) params.get(0);\n        String transactionHash = normalizeHash(Hash.sha3(data));\n        try {\n            Transaction existingTransaction = crossStorageApi\n                    .find(defaultRepo, Transaction.class)\n                    .by(\"hexHash\", transactionHash).getResult();\n            if (existingTransaction != null) {\n                return createErrorResponse(\n                        requestId,\n                        TRANSACTION_REJECTED,\n                        String.format(TRANSACTION_EXISTS_ERROR, transactionHash));\n            }\n        } catch (Exception e) {\n            return createErrorResponse(requestId, RESOURCE_NOT_FOUND, e.getMessage());\n        }\n\n        RawTransaction rawTransaction = TransactionDecoder.decode(data);\n        LOG.info(\"to:{} , value:{}\", rawTransaction.getTo(), rawTransaction.getValue());\n\n        if (rawTransaction instanceof SignedRawTransaction) {\n            SignedRawTransaction signedTransaction = (SignedRawTransaction) rawTransaction;\n            Sign.SignatureData signatureData = signedTransaction.getSignatureData();\n            try {\n                String v = toHex(signatureData.getV());\n                String s = toHex(signatureData.getS());\n                String r = toHex(signatureData.getR());\n                LOG.info(\"from:{} chainId:{} , v:{} , r:{} , s:{}\",\n                         signedTransaction.getFrom(), signedTransaction.getChainId(), v, r, s);\n                String extraData = rawTransaction.getData();\n                if (extraData == null || extraData.isEmpty()) {\n                    extraData = \"{\\\"type\\\":\\\"transfer\\\",\\\"description\\\":\\\"Transfer coins\\\"}\";\n                }\n                Transaction transaction = new Transaction();\n                transaction.setHexHash(transactionHash);\n                transaction.setFromHexHash(normalizeHash(signedTransaction.getFrom()));\n                transaction.setToHexHash(normalizeHash(rawTransaction.getTo()));\n                transaction.setNonce(\"\" + rawTransaction.getNonce());\n                transaction.setGasPrice(\"\" + rawTransaction.getGasPrice());\n                transaction.setGasLimit(\"\" + rawTransaction.getGasLimit());\n                transaction.setValue(\"\" + rawTransaction.getValue());\n                transaction.setSignedHash(data);\n                transaction.setData(extraData);\n                transaction.setCreationDate(java.time.Instant.now());\n                transaction.setV(v);\n                transaction.setS(s);\n                transaction.setR(r);\n                String uuid = crossStorageApi.createOrUpdate(defaultRepo, transaction);\n                LOG.info(\"Created transaction on DB with uuid: {}\", uuid);\n            } catch (Exception e) {\n                return createErrorResponse(requestId, TRANSACTION_REJECTED, e.getMessage());\n            }\n        }\n        return result;\n    }\n}\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ ],
  "importScriptInstances" : [ {
    "code" : "io.liquichain.api.rpc.BlockchainProcessor",
    "inputs" : [ ],
    "outputs" : [ {
      "name" : "result",
      "type" : "String"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package io.liquichain.api.rpc;\n\nimport static io.liquichain.api.rpc.EthApiConstants.*;\n\nimport org.meveo.admin.exception.BusinessException;\nimport org.meveo.api.exception.EntityDoesNotExistsException;\nimport org.meveo.api.persistence.CrossStorageApi;\nimport org.meveo.commons.utils.ParamBean;\nimport org.meveo.commons.utils.ParamBeanFactory;\nimport org.meveo.model.customEntities.VerifiedEmail;\nimport org.meveo.model.customEntities.VerifiedPhoneNumber;\nimport org.meveo.model.customEntities.Wallet;\nimport org.meveo.model.storage.Repository;\nimport org.meveo.service.script.Script;\nimport org.meveo.service.storage.RepositoryService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigInteger;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.web3j.crypto.*;\nimport org.web3j.utils.*;\n\npublic class BlockchainProcessor extends Script {\n    private static final Logger LOG = LoggerFactory.getLogger(BlockchainProcessor.class);\n    private static final Map<String, Object[]> TRANSACTION_HOOKS = new HashMap<>();\n\n    private final RepositoryService repositoryService = getCDIBean(RepositoryService.class);\n    private ParamBeanFactory paramBeanFactory = getCDIBean(ParamBeanFactory.class);\n\n    protected final CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\n    protected final Repository defaultRepo = repositoryService.findDefaultRepository();\n    protected ParamBean config = paramBeanFactory.getInstance();\n\n    protected String result;\n\n    public String getResult() {\n        return this.result;\n    }\n\n    public static boolean addTransactionHook(String regex, Script script) {\n        boolean isHookAdded = true;\n        String key = regex + \":\" + script.getClass().getName();\n        LOG.info(\"addTransactionHook key: {}\", key);\n        isHookAdded = !TRANSACTION_HOOKS.containsKey(key);\n        if (isHookAdded) {\n            Pattern pattern = Pattern.compile(regex);\n            TRANSACTION_HOOKS.put(key, new Object[]{pattern, script});\n        }\n        return isHookAdded;\n    }\n\n    protected void processTransactionHooks(String transactionHash, SignedRawTransaction transaction) {\n        try {\n            String data = new String(new BigInteger(transaction.getData(), 16).toByteArray());\n            LOG.info(\"try matching {} hooks\", TRANSACTION_HOOKS.size());\n            TRANSACTION_HOOKS.forEach((String key, Object[] hook) -> {\n                LOG.info(\"try hook {} on {}\", key, data);\n                Pattern pattern = (Pattern) hook[0];\n                Script script = (Script) hook[1];\n                Matcher matcher = pattern.matcher(data);\n                if (matcher.find()) {\n                    LOG.info(\" hook {} matched\", key);\n                    Map<String, Object> context = new HashMap<>();\n                    context.put(\"transaction\", transaction);\n                    context.put(\"transactionHash\", transactionHash);\n                    context.put(\"matcher\", matcher);\n                    try {\n                        script.execute(context);\n                        if (context.containsKey(\"result\")) {\n                            LOG.info(\" hook result:{} \", context.get(\"result\"));\n                        }\n                    } catch (Exception e) {\n                        LOG.error(\"error while invoking transaction hook {}\", script, e);\n                    }\n                } else {\n                    LOG.info(\" hook {} matched\", key);\n                }\n            });\n            if (data.contains(\"orderId\")) {\n                LOG.info(\"detected orderId:{}\", data);\n            }\n        } catch (Exception ex) {\n            LOG.info(\"error while detecting order:{}\", ex);\n        }\n    }\n\n    protected String createResponse(String requestId, String response) {\n        return EthApiUtils.createResponse(requestId, response);\n    }\n\n    protected String createErrorResponse(String requestId, String errorCode, String message) {\n        return EthApiUtils.createErrorResponse(requestId, errorCode, message);\n    }\n\n    protected String normalizeHash(String hash) {\n        return EthApiUtils.normalizeHash(hash);\n    }\n\n    protected String retrieveHash(List<String> parameters, int parameterIndex) {\n        return normalizeHash(parameters.get(parameterIndex));\n    }\n\n    protected boolean isJSONValid(String json) {\n        return EthApiUtils.isJSONValid(json);\n    }\n\n    protected String toHex(byte[] bytes) {\n        return EthApiUtils.toHex(bytes);\n    }\n\n    protected String toBigHex(String value) {\n        return EthApiUtils.toBigHex(value);\n    }\n\n    protected String validateName(String name) throws BusinessException {\n        if (name == null || name.trim().isEmpty()) {\n            throw new BusinessException(NAME_REQUIRED_ERROR);\n        }\n        Wallet walletWithSameName = null;\n        try {\n            walletWithSameName = crossStorageApi\n                    .find(defaultRepo, Wallet.class)\n                    .by(\"name\", name)\n                    .getResult();\n        } catch (Exception e) {\n            // do nothing, we want wallet name to be unique\n        }\n        if (walletWithSameName != null) {\n            String error = String.format(NAME_EXISTS_ERROR, name);\n            LOG.error(error);\n            throw new BusinessException(error);\n        }\n        return name;\n    }\n\n    protected String validateEmail(String email, String walletId) throws BusinessException {\n        // if (email == null || email.trim().isEmpty()) {\n        // throw new BusinessException(EMAIL_REQUIRED_ERROR);\n        // }\n        if (email != null && !email.trim().isEmpty()) {\n            VerifiedEmail existingEmail = null;\n            try {\n                existingEmail = crossStorageApi\n                        .find(defaultRepo, VerifiedEmail.class)\n                        .by(\"email\", email)\n                        .by(\"not-inList walletId\", Arrays.asList(walletId))\n                        .getResult();\n            } catch (Exception e) {\n                // do nothing, we want email address to be unique\n            }\n            if (existingEmail != null) {\n                String error = String.format(EMAIL_EXISTS_ERROR, email);\n                LOG.error(error);\n                throw new BusinessException(error);\n            }\n        }\n        return email;\n    }\n\n    protected String validatePhoneNumber(String phoneNumber, String walletId)\n            throws BusinessException {\n        if (phoneNumber == null || phoneNumber.trim().isEmpty()) {\n            throw new BusinessException(PHONE_NUMBER_REQUIRED_ERROR);\n        }\n        VerifiedPhoneNumber existingPhoneNumber = null;\n        try {\n            existingPhoneNumber = crossStorageApi\n                    .find(defaultRepo, VerifiedPhoneNumber.class)\n                    .by(\"phoneNumber\", phoneNumber)\n                    .by(\"not-inList walletId\", Arrays.asList(walletId))\n                    .getResult();\n        } catch (Exception e) {\n            // do nothing, we want wallet phoneNumber to be unique\n        }\n        if (existingPhoneNumber != null) {\n            String error = String.format(PHONE_NUMBER_EXISTS_ERROR, phoneNumber);\n            LOG.error(error);\n            throw new BusinessException(error);\n        }\n        return phoneNumber;\n    }\n\n    protected String parseAddress(String signature, String message) throws Exception {\n        byte[] messageHash = Hash.sha3(message.getBytes(StandardCharsets.UTF_8));\n        LOG.info(\"messageHash={}\", Numeric.toHexString(messageHash));\n        String r = signature.substring(0, 66);\n        String s = \"0x\" + signature.substring(66, 130);\n        String v = \"0x\" + signature.substring(130, 132);\n        String publicKey = Sign\n                .signedMessageHashToKey(\n                        messageHash,\n                        new Sign.SignatureData(\n                                Numeric.hexStringToByteArray(v)[0],\n                                Numeric.hexStringToByteArray(r),\n                                Numeric.hexStringToByteArray(s)\n                        )\n                )\n                .toString(16);\n        String address = Keys.getAddress(publicKey);\n        LOG.info(\"address: \" + address);\n        return address;\n    }\n\n    protected <T> T findEntity(String uuid, Class<T> clazz) {\n        T entity = null;\n        try {\n            entity = crossStorageApi.find(defaultRepo, uuid, clazz);\n        } catch (EntityDoesNotExistsException e) {\n            LOG.warn(\"No {} with uuid: {}\", clazz.getSimpleName(), uuid);\n        }\n        return entity;\n    }\n}\n",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ ],
    "importScriptInstances" : [ ]
  } ]
}