{
  "code" : "io.liquichain.api.rpc.BlockchainProcessor",
  "inputs" : [ ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.rpc;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.meveo.admin.exception.BusinessException;\nimport org.meveo.api.exception.EntityDoesNotExistsException;\nimport org.meveo.api.persistence.CrossStorageApi;\nimport org.meveo.commons.utils.ParamBean;\nimport org.meveo.commons.utils.ParamBeanFactory;\nimport org.meveo.model.customEntities.VerifiedEmail;\nimport org.meveo.model.customEntities.VerifiedPhoneNumber;\nimport org.meveo.model.customEntities.Wallet;\nimport org.meveo.model.storage.Repository;\nimport org.meveo.service.script.Script;\nimport org.meveo.service.storage.RepositoryService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigInteger;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.web3j.crypto.*;\nimport org.web3j.utils.*;\n\nimport static io.liquichain.api.rpc.EthApiConstants.*;\n\npublic class BlockchainProcessor extends Script {\n    private static final Logger LOG = LoggerFactory.getLogger(BlockchainProcessor.class);\n    private static final Map<String, Object[]> TRANSACTION_HOOKS = new HashMap<>();\n\n    private final RepositoryService repositoryService = getCDIBean(RepositoryService.class);\n    private ParamBeanFactory paramBeanFactory = getCDIBean(ParamBeanFactory.class);\n\n    protected final CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\n    protected final Repository defaultRepo = repositoryService.findDefaultRepository();\n    protected ParamBean config = paramBeanFactory.getInstance();\n\n    protected String result;\n\n    public String getResult() {\n        return this.result;\n    }\n\n    public static boolean addTransactionHook(String regex, Script script) {\n        boolean isHookAdded = true;\n        String key = regex + \":\" + script.getClass().getName();\n        LOG.info(\"addTransactionHook key: {}\", key);\n        isHookAdded = !TRANSACTION_HOOKS.containsKey(key);\n        if (isHookAdded) {\n            Pattern pattern = Pattern.compile(regex);\n            TRANSACTION_HOOKS.put(key, new Object[]{pattern, script});\n        }\n        return isHookAdded;\n    }\n\n    protected void processTransactionHooks(String transactionHash, SignedRawTransaction transaction) {\n        try {\n            String data = new String(new BigInteger(transaction.getData(), 16).toByteArray());\n            LOG.info(\"try matching {} hooks\", TRANSACTION_HOOKS.size());\n            TRANSACTION_HOOKS.forEach((String key, Object[] hook) -> {\n                LOG.info(\"try hook {} on {}\", key, data);\n                Pattern pattern = (Pattern) hook[0];\n                Script script = (Script) hook[1];\n                Matcher matcher = pattern.matcher(data);\n                if (matcher.find()) {\n                    LOG.info(\" hook {} matched\", key);\n                    Map<String, Object> context = new HashMap<>();\n                    context.put(\"transaction\", transaction);\n                    context.put(\"transactionHash\", transactionHash);\n                    context.put(\"matcher\", matcher);\n                    try {\n                        script.execute(context);\n                        if (context.containsKey(\"result\")) {\n                            LOG.info(\" hook result:{} \", context.get(\"result\"));\n                        }\n                    } catch (Exception e) {\n                        LOG.error(\"error while invoking transaction hook {}\", script, e);\n                    }\n                } else {\n                    LOG.info(\" hook {} matched\", key);\n                }\n            });\n            if (data.contains(\"orderId\")) {\n                LOG.info(\"detected orderId:{}\", data);\n            }\n        } catch (Exception ex) {\n            LOG.info(\"error while detecting order:{}\", ex);\n        }\n    }\n\n    protected String createResponse(String requestId, String response) {\n        return EthApiUtils.createResponse(requestId, response);\n    }\n\n    protected String createErrorResponse(String requestId, String errorCode, String message) {\n        return EthApiUtils.createErrorResponse(requestId, errorCode, message);\n    }\n\n    protected String normalizeHash(String hash) {\n        return EthApiUtils.normalizeHash(hash);\n    }\n\n    protected String retrieveHash(List<String> parameters, int parameterIndex) {\n        return normalizeHash(parameters.get(parameterIndex));\n    }\n\n    protected boolean isJSONValid(String json) {\n        return EthApiUtils.isJSONValid(json);\n    }\n\n    protected String toHex(byte[] bytes) {\n        return EthApiUtils.toHex(bytes);\n    }\n\n    protected String toBigHex(String value) {\n        return EthApiUtils.toBigHex(value);\n    }\n\n    protected String validateName(String name) throws BusinessException {\n        if (name == null || name.trim().isEmpty()) {\n            throw new BusinessException(NAME_REQUIRED_ERROR);\n        }\n        Wallet walletWithSameName = null;\n        try {\n            walletWithSameName = crossStorageApi\n                    .find(defaultRepo, Wallet.class)\n                    .by(\"name\", name)\n                    .getResult();\n        } catch (Exception e) {\n            // do nothing, we want wallet name to be unique\n        }\n        if (walletWithSameName != null) {\n            String error = String.format(NAME_EXISTS_ERROR, name);\n            LOG.error(error);\n            throw new BusinessException(error);\n        }\n        return name;\n    }\n\n    protected String validateEmail(String email, String walletId) throws BusinessException {\n        // if (email == null || email.trim().isEmpty()) {\n        // throw new BusinessException(EMAIL_REQUIRED_ERROR);\n        // }\n        if (email != null && !email.trim().isEmpty()) {\n            VerifiedEmail existingEmail = null;\n            try {\n                existingEmail = crossStorageApi\n                        .find(defaultRepo, VerifiedEmail.class)\n                        .by(\"email\", email)\n                        .by(\"not-inList walletId\", Arrays.asList(walletId))\n                        .getResult();\n            } catch (Exception e) {\n                // do nothing, we want email address to be unique\n            }\n            if (existingEmail != null) {\n                String error = String.format(EMAIL_EXISTS_ERROR, email);\n                LOG.error(error);\n                throw new BusinessException(error);\n            }\n        }\n        return email;\n    }\n\n    protected String validatePhoneNumber(String phoneNumber, String walletId)\n            throws BusinessException {\n        if (phoneNumber == null || phoneNumber.trim().isEmpty()) {\n            throw new BusinessException(PHONE_NUMBER_REQUIRED_ERROR);\n        }\n        VerifiedPhoneNumber existingPhoneNumber = null;\n        try {\n            existingPhoneNumber = crossStorageApi\n                    .find(defaultRepo, VerifiedPhoneNumber.class)\n                    .by(\"phoneNumber\", phoneNumber)\n                    .by(\"not-inList walletId\", Arrays.asList(walletId))\n                    .getResult();\n        } catch (Exception e) {\n            // do nothing, we want wallet phoneNumber to be unique\n        }\n        if (existingPhoneNumber != null) {\n            String error = String.format(PHONE_NUMBER_EXISTS_ERROR, phoneNumber);\n            LOG.error(error);\n            throw new BusinessException(error);\n        }\n        return phoneNumber;\n    }\n\n    protected String parseAddress(String signature, String message) throws Exception {\n        byte[] messageHash = Hash.sha3(message.getBytes(StandardCharsets.UTF_8));\n        LOG.info(\"messageHash={}\", Numeric.toHexString(messageHash));\n        String r = signature.substring(0, 66);\n        String s = \"0x\" + signature.substring(66, 130);\n        String v = \"0x\" + signature.substring(130, 132);\n        String publicKey = Sign\n                .signedMessageHashToKey(\n                        messageHash,\n                        new Sign.SignatureData(\n                                Numeric.hexStringToByteArray(v)[0],\n                                Numeric.hexStringToByteArray(r),\n                                Numeric.hexStringToByteArray(s)\n                        )\n                )\n                .toString(16);\n        String address = Keys.getAddress(publicKey);\n        LOG.info(\"address: \" + address);\n        return address;\n    }\n\n    protected <T> T findEntity(String uuid, Class<T> clazz) {\n        T entity = null;\n        try {\n            entity = crossStorageApi.find(defaultRepo, uuid, clazz);\n        } catch (EntityDoesNotExistsException e) {\n            LOG.warn(\"No {} with uuid: {}\", clazz.getSimpleName(), uuid);\n        }\n        return entity;\n    }\n}\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ ],
  "importScriptInstances" : [ ]
}