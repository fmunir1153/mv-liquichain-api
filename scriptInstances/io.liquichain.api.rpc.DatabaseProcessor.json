{
  "code" : "io.liquichain.api.rpc.DatabaseProcessor",
  "inputs" : [ ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.rpc;\r\n\r\nimport static io.liquichain.api.rpc.EthApiConstants.*;\r\n\r\nimport java.math.BigInteger;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.meveo.model.customEntities.Transaction;\r\nimport org.meveo.model.customEntities.Wallet;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport org.web3j.crypto.*;\r\nimport org.web3j.utils.*;\r\n\r\nimport io.liquichain.api.rpc.BlockchainProcessor;\r\nimport io.liquichain.core.BlockForgerScript;\r\n\r\npublic class DatabaseProcessor extends BlockchainProcessor {\r\n    private static final Logger LOG = LoggerFactory.getLogger(DatabaseProcessor.class);\r\n\r\n    private static final String SAMPLE_BLOCK = \"{\" + \"\\\"difficulty\\\":\\\"0x5\\\",\"\r\n            + \"\\\"extraData\" +\r\n            \"\\\":\\\"0xd58301090083626f7286676f312e3133856c696e75780000000000000000000021c9effaf6549e725463c7877ddebe9a2916e03228624e4bfd1e3f811da792772b54d9e4eb793c54afb4a29f014846736755043e4778999046d0577c6e57e72100\\\",\"\r\n            + \"\\\"gasLimit\\\":\\\"0xe984c2\\\",\" + \"\\\"gasUsed\\\":\\\"0x0\\\",\"\r\n            + \"\\\"hash\\\":\\\"0xaa14340feb15e26bc354bb839b2aa41cc7984676249c155ac5e4d281a8d08809\\\",\"\r\n            + \"\\\"logsBloom\" +\r\n            \"\\\":\\\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\\",\"\r\n            + \"\\\"miner\\\":\\\"0x0000000000000000000000000000000000000000\\\",\"\r\n            + \"\\\"mixHash\\\":\\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\",\"\r\n            + \"\\\"nonce\\\":\\\"0x0000000000000000\\\",\" + \"\\\"number\\\":\\\"0x1b4\\\",\"\r\n            + \"\\\"parentHash\\\":\\\"0xc8ccb81f484a428a3a1669d611f55f880b362b612f726711947d98f5bc5af573\\\",\"\r\n            + \"\\\"receiptsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\"\r\n            + \"\\\"sha3Uncles\\\":\\\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\\\",\"\r\n            + \"\\\"size\\\":\\\"0x260\\\",\"\r\n            + \"\\\"stateRoot\\\":\\\"0xffcb834d62706995e9e7bf10cc9a9e42a82fea998d59b3a5cfad8975dbfe3f87\\\",\"\r\n            + \"\\\"timestamp\\\":\\\"0x5ed9a43f\\\",\" + \"\\\"totalDifficulty\\\":\\\"0x881\\\",\" + \"\\\"transactions\\\":[\"\r\n            + \"],\"\r\n            + \"\\\"transactionsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\"\r\n            + \"\\\"uncles\\\":[  \" + \"]}\";\r\n\r\n    @Override\r\n    public void execute(Map<String, Object> parameters) throws BusinessException {\r\n        String method = \"\" + parameters.get(\"method\");\r\n        LOG.info(\"json rpc: {}, parameters:{}\", method, parameters);\r\n        String requestId = \"\" + parameters.get(\"id\");\r\n        switch (method) {\r\n            case \"eth_call\":\r\n                result = createResponse(requestId, \"0x\");\r\n                break;\r\n            case \"eth_chainId\":\r\n                result = createResponse(requestId, \"0x4c\");\r\n                break;\r\n            case \"web3_clientVersion\":\r\n                result = createResponse(requestId, \"liquichainCentral\");\r\n                break;\r\n            case \"net_version\":\r\n                result = createResponse(requestId, \"7\");\r\n                break;\r\n            case \"eth_blockNumber\":\r\n                result = createResponse(requestId, \"0x\" + Long.toHexString(BlockForgerScript.blockHeight));\r\n                break;\r\n            case \"eth_getBalance\":\r\n                result = getBalance(requestId, parameters);\r\n                break;\r\n            case \"eth_getTransactionCount\":\r\n                result = getTransactionCount(requestId, parameters);\r\n                break;\r\n            case \"eth_getBlockByNumber\":\r\n                result = createResponse(requestId, SAMPLE_BLOCK);\r\n                break;\r\n            case \"eth_estimateGas\":\r\n                result = createResponse(requestId, \"0x0\");\r\n                break;\r\n            case \"eth_gasPrice\":\r\n                result = createResponse(requestId, \"0x0\");\r\n                break;\r\n            case \"eth_getCode\":\r\n                result = getCode(requestId, parameters);\r\n                break;\r\n            case \"eth_sendRawTransaction\":\r\n                result = sendRawTransaction(requestId, parameters);\r\n                break;\r\n            case \"eth_getTransactionByHash\":\r\n                result = getTransactionByHash(requestId, parameters);\r\n                break;\r\n            default:\r\n                result = createErrorResponse(requestId, METHOD_NOT_FOUND, NOT_IMPLEMENTED_ERROR);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private String getTransactionByHash(String requestId, Map<String, Object> parameters) {\r\n        List<String> params = (List<String>) parameters.get(\"params\");\r\n        String hash = retrieveHash(params, 0);\r\n        LOG.info(\"lookup transaction hexHash={}\", hash);\r\n\r\n        try {\r\n            Transaction transaction = crossStorageApi\r\n                    .find(defaultRepo, Transaction.class)\r\n                    .by(\"hexHash\", hash)\r\n                    .getResult();\r\n            String transactionDetails = \"{\\n\";\r\n            transactionDetails += \"\\\"blockHash\\\": \\\"0x\" + transaction.getBlockHash() + \"\\\",\\n\";\r\n            transactionDetails += \"\\\"blockNumber\\\": \\\"\" + toBigHex(transaction.getBlockNumber()) + \"\\\",\\n\";\r\n            transactionDetails += \"\\\"from\\\": \\\"0x\" + transaction.getFromHexHash() + \"\\\",\\n\";\r\n            transactionDetails += \"\\\"gas\\\": \\\"\" + toBigHex(transaction.getGasLimit()) + \"\\\",\\n\";\r\n            transactionDetails += \"\\\"gasPrice\\\": \\\"\" + toBigHex(transaction.getGasPrice()) + \"\\\",\\n\";\r\n            transactionDetails += \"\\\"hash\\\": \\\"\" + hash + \"\\\",\\n\";\r\n            transactionDetails += \"\\\"input\\\": \\\"\\\",\\n\";\r\n            transactionDetails += \"\\\"nonce\\\": \\\"\" + toBigHex(transaction.getNonce()) + \"\\\",\\n\";\r\n            if (transaction.getData() != null) {\r\n                if (isJSONValid(transaction.getData())) {\r\n                    transactionDetails += \"\\\"data\\\": \" + transaction.getData() + \",\\n\";\r\n                } else {\r\n                    transactionDetails += \"\\\"data\\\": \\\"\" + transaction.getData() + \"\\\",\\n\";\r\n                }\r\n            }\r\n            transactionDetails += \"\\\"r\\\": \\\"\" + transaction.getR() + \"\\\",\\n\";\r\n            transactionDetails += \"\\\"s\\\": \\\"\" + transaction.getS() + \"\\\",\\n\";\r\n            transactionDetails += \"\\\"to\\\": \\\"0x\" + transaction.getToHexHash() + \"\\\",\\n\";\r\n            transactionDetails +=\r\n                    \"\\\"transactionIndex\\\": \\\"0x\" + toBigHex(transaction.getTransactionIndex() + \"\") + \"\\\",\";\r\n            transactionDetails += \"\\\"v\\\": \\\"\" + transaction.getV() + \"\\\",\";\r\n            transactionDetails += \"\\\"value\\\": \\\"\" + toBigHex(transaction.getValue()) + \"\\\"\\n\";\r\n            transactionDetails += \"}\";\r\n            LOG.info(\"res={}\" + transactionDetails);\r\n            return createResponse(requestId, transactionDetails);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return createErrorResponse(requestId, RESOURCE_NOT_FOUND, \"Resource not found\");\r\n        }\r\n    }\r\n\r\n    private String sendRawTransaction(String requestId, Map<String, Object> parameters) {\r\n        List<String> params = (List<String>) parameters.get(\"params\");\r\n        String transactionData = params.get(0);\r\n        String transactionHash = normalizeHash(Hash.sha3(transactionData));\r\n        Transaction existingTransaction = null;\r\n        result = \"0x0\";\r\n        try {\r\n            existingTransaction = crossStorageApi\r\n                    .find(defaultRepo, Transaction.class)\r\n                    .by(\"hexHash\", transactionHash)\r\n                    .getResult();\r\n        } catch (Exception e) {\r\n            // do nothing, we want transaction to be unique\r\n        }\r\n        if (existingTransaction != null) {\r\n            return createErrorResponse(requestId, INVALID_REQUEST, TRANSACTION_EXISTS_ERROR);\r\n        }\r\n\r\n        RawTransaction rawTransaction = TransactionDecoder.decode(transactionData);\r\n\r\n        if (rawTransaction instanceof SignedRawTransaction) {\r\n            SignedRawTransaction signedResult = (SignedRawTransaction) rawTransaction;\r\n            Sign.SignatureData signatureData = signedResult.getSignatureData();\r\n            try {\r\n                LOG.info(\"from:{} chainedId:{}\", signedResult.getFrom(), signedResult.getChainId());\r\n                Transaction transaction = new Transaction();\r\n                transaction.setHexHash(transactionHash);\r\n                transaction.setFromHexHash(normalizeHash(signedResult.getFrom()));\r\n                transaction.setToHexHash(normalizeHash(rawTransaction.getTo()));\r\n                transaction.setNonce(\"\" + rawTransaction.getNonce());\r\n                transaction.setGasPrice(\"\" + rawTransaction.getGasPrice());\r\n                transaction.setGasLimit(\"\" + rawTransaction.getGasLimit());\r\n                transaction.setValue(\"\" + rawTransaction.getValue());\r\n                if (rawTransaction.getData() == null || rawTransaction.getData().isEmpty()) {\r\n                    transaction.setData(\"{\\\"type\\\":\\\"transfer\\\"}\");\r\n                } else {\r\n                    transaction.setData(\"\" + rawTransaction.getData());\r\n                }\r\n                transaction.setSignedHash(transactionData);\r\n                transaction.setCreationDate(java.time.Instant.now());\r\n                transaction.setV(toHex(signatureData.getV()));\r\n                transaction.setS(toHex(signatureData.getS()));\r\n                transaction.setR(toHex(signatureData.getR()));\r\n                LOG.info(\"transaction:{}\", transaction);\r\n                String uuid = crossStorageApi.createOrUpdate(defaultRepo, transaction);\r\n                transferValue(transaction, rawTransaction.getValue());\r\n                result = \"0x\" + transactionHash;\r\n                LOG.info(\"created transaction with uuid:{}\", uuid);\r\n                if (rawTransaction.getData() != null && rawTransaction.getData().length() > 0) {\r\n                    processTransactionHooks(transaction.getHexHash(), signedResult);\r\n                }\r\n            } catch (Exception e) {\r\n                return createErrorResponse(requestId, TRANSACTION_REJECTED, e.getMessage());\r\n            }\r\n        }\r\n        return createResponse(requestId, result);\r\n    }\r\n\r\n    private void transferValue(Transaction transaction, BigInteger value) throws BusinessException {\r\n        String message = \"transfer error\";\r\n        try {\r\n            message = \"cannot find origin wallet\";\r\n            Wallet originWallet = crossStorageApi.find(defaultRepo, transaction.getFromHexHash(), Wallet.class);\r\n            message = \"cannot find destination wallet\";\r\n            crossStorageApi.find(defaultRepo, transaction.getToHexHash(), Wallet.class);\r\n            message = \"insufficient balance\";\r\n            BigInteger originBalance = new BigInteger(originWallet.getBalance());\r\n            LOG.info(\"originWallet 0x{} old balance:{}\", transaction.getFromHexHash(),\r\n                     originWallet.getBalance());\r\n            if (value.compareTo(originBalance) <= 0) {\r\n                BlockForgerScript.addTransaction(transaction);\r\n            } else {\r\n                throw new BusinessException(\"insufficient balance\");\r\n            }\r\n        } catch (Exception e) {\r\n            throw new BusinessException(message);\r\n        }\r\n    }\r\n\r\n    private String getTransactionCount(String requestId, Map<String, Object> parameters) {\r\n        List<String> params = (List<String>) parameters.get(\"params\");\r\n        String transactionHash = retrieveHash(params, 0);\r\n        try {\r\n            int nbTransaction = (crossStorageApi.find(defaultRepo, Transaction.class)\r\n                                                .by(\"fromHexHash\", transactionHash)\r\n                                                .getResults()).size();\r\n            return createResponse(requestId, toBigHex(nbTransaction + \"\"));\r\n        } catch (Exception e) {\r\n            return createResponse(requestId, \"0x0\");\r\n        }\r\n    }\r\n\r\n    private String getCode(String requestId, Map<String, Object> parameters) {\r\n        List<String> params = (List<String>) parameters.get(\"params\");\r\n        String address = retrieveHash(params, 0);\r\n        try {\r\n            Wallet wallet = crossStorageApi.find(defaultRepo, address, Wallet.class);\r\n            LOG.info(\"getCode wallet.application.uuid={}\", wallet.getApplication().getUuid());\r\n            return createResponse(requestId, \"0x\" + wallet.getApplication().getUuid());\r\n        } catch (Exception e) {\r\n            LOG.error(\"Wallet address {} not found\", address, e);\r\n            return createErrorResponse(requestId, RESOURCE_NOT_FOUND, \"Address not found\");\r\n        }\r\n    }\r\n\r\n    private String getBalance(String requestId, Map<String, Object> parameters) {\r\n        List<String> params = (List<String>) parameters.get(\"params\");\r\n        String address = retrieveHash(params, 0);\r\n        try {\r\n            Wallet wallet = crossStorageApi.find(defaultRepo, address, Wallet.class);\r\n            return createResponse(requestId, toBigHex(wallet.getBalance()));\r\n        } catch (Exception e) {\r\n\r\n            return createErrorResponse(requestId, RESOURCE_NOT_FOUND, \"Resource not found\");\r\n        }\r\n    }\r\n}\r\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ ],
  "importScriptInstances" : [ {
    "code" : "io.liquichain.core.BlockForgerScript",
    "description" : "Bock forging script",
    "inputs" : [ ],
    "outputs" : [ {
      "name" : "lastBlock",
      "type" : "Block"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package io.liquichain.core;\r\n\r\nimport java.util.Map;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Arrays;\r\nimport java.util.ArrayList;\r\nimport java.math.BigInteger;\r\nimport java.time.Instant;\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\nimport java.util.stream.Collectors;\r\nimport java.io.IOException;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.math.BigInteger;\r\nimport org.meveo.model.customEntities.Block;\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.customEntities.Transaction;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.persistence.CrossStorageService;\r\nimport org.meveo.cache.CustomFieldsCacheContainerProvider;\r\nimport org.meveo.api.exception.EntityDoesNotExistsException;\r\nimport org.meveo.admin.util.pagination.PaginationConfiguration;\r\nimport org.meveo.model.persistence.CEIUtils;\r\nimport org.meveo.service.custom.CustomTableService;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.primefaces.model.SortOrder;\r\n\r\nimport org.web3j.crypto.*;\r\n\r\npublic class BlockForgerScript extends Script {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(BlockForgerScript.class);\r\n  \r\n    private static long chainId=76;\r\n\r\n    private int networkId = 7;\r\n\r\n    static public long blockHeight = 1;\r\n  \r\n    private Block parentBlock=null;\r\n    \r\n    private String exampleBlock = \"{\" +\r\n      \"\\\"difficulty\\\":\\\"0x5\\\",\" +\r\n      \"\\\"extraData\\\":\\\"0xd58301090083626f7286676f312e3133856c696e75780000000000000000000021c9effaf6549e725463c7877ddebe9a2916e03228624e4bfd1e3f811da792772b54d9e4eb793c54afb4a29f014846736755043e4778999046d0577c6e57e72100\\\",\"\r\n      + \"\\\"gasLimit\\\":\\\"0xe984c2\\\",\" + \"\\\"gasUsed\\\":\\\"0x0\\\",\" \r\n      + \"\\\"hash\\\":\\\"0xaa14340feb15e26bc354bb839b2aa41cc7984676249c155ac5e4d281a8d08809\\\",\"\r\n      + \"\\\"logsBloom\\\":\\\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\\",\"\r\n      + \"\\\"miner\\\":\\\"0x0000000000000000000000000000000000000000\\\",\" +\r\n      \"\\\"mixHash\\\":\\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\",\" +\r\n      \"\\\"nonce\\\":\\\"0x0000000000000000\\\",\" +\r\n      \"\\\"number\\\":\\\"0x1b4\\\",\" +\r\n      \"\\\"parentHash\\\":\\\"0xc8ccb81f484a428a3a1669d611f55f880b362b612f726711947d98f5bc5af573\\\",\" + \r\n      \"\\\"receiptsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" +\r\n      \"\\\"sha3Uncles\\\":\\\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\\\",\" +\r\n      \"\\\"size\\\":\\\"0x260\\\",\" +\r\n      \"\\\"stateRoot\\\":\\\"0xffcb834d62706995e9e7bf10cc9a9e42a82fea998d59b3a5cfad8975dbfe3f87\\\",\" +\r\n      \"\\\"timestamp\\\":\\\"0x5ed9a43f\\\",\" +\r\n      \"\\\"totalDifficulty\\\":\\\"0x881\\\",\" +\r\n      \"\\\"transactions\\\":[\" + \"],\" + \r\n      \"\\\"transactionsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" + \r\n      \"\\\"uncles\\\":[  \" + \"]}\";\r\n\r\n      \r\n\tprivate CustomFieldsCacheContainerProvider cetCache = getCDIBean(CustomFieldsCacheContainerProvider.class);\r\n    private CrossStorageService crossStorageService = getCDIBean(CrossStorageService.class);\r\n    private CustomTableService customTableService = getCDIBean(CustomTableService.class);\r\n    \r\n    private static PaginationConfiguration lastBlockPC = new PaginationConfiguration(\"blockNumber\",SortOrder.DESCENDING);\r\n  \r\n  \tprivate CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\r\n\r\n    \r\n    private static List<Transaction> currentTransactions = new ArrayList<>();\r\n    private static List<Transaction> nextTransactions = new ArrayList<>();\r\n  \r\n    private static Instant nextBlockDate;\r\n    private static AtomicBoolean isForging = new AtomicBoolean(false);\r\n  \r\n    public static void addTransaction(Transaction t){\r\n      if(isForging.get()){\r\n          nextTransactions.add(t);\r\n      } else {\r\n          currentTransactions.add(t);\r\n      }\r\n    }\r\n  \r\n    public Block getLastBlock(){\r\n        Block result = null;\r\n        try{\r\n            //log.info(\"query : \"+customTableService.getQuery(\"block\", lastBlockPC));\r\n        List<Map<String, Object>> res = crossStorageService.find(defaultRepo, cetCache.getCustomEntityTemplate(\"Block\"), lastBlockPC);\r\n        if(res.size()>0){\r\n            result = CEIUtils.deserialize(res.get(0), Block.class);\r\n            //log.info(\"lastBlock number:{}\",result.getBlockNumber());\r\n        }\r\n        } catch(Exception e){\r\n          log.error(\"getLastBlock:{}\",e);\r\n        }\r\n        return result;\r\n    }\r\n  \r\n    @Override\r\n    public void execute(Map<String, Object> parameters) throws BusinessException {\r\n      //log.info(\"execute forging\");\r\n      if(parentBlock==null){\r\n      \t//log.info(\"retreive last block from chain\");\r\n        parentBlock = getLastBlock();\r\n      }\r\n      if(isForging.getAndSet(true)){\r\n         log.error(\"we are already forging\");\r\n         return;\r\n      } \r\n      if(currentTransactions.size()==0){\r\n        //log.info(\"no transaction to forge\");\r\n        blockHeight=parentBlock.getBlockNumber();\r\n        isForging.set(false);\r\n        return;\r\n      } else {\r\n        log.info(\"forging {} transactions\",currentTransactions.size());\r\n        Map<String,Wallet> wallets = new HashMap<>();\r\n        List<Transaction> orderedTransactions = currentTransactions.stream().sorted((t1,t2)->(t1.getCreationDate().compareTo(t2.getCreationDate()))).collect(Collectors.toList());\r\n        \r\n        blockHeight=parentBlock.getBlockNumber()+1;\r\n        \r\n        String transactionHashes=\"\";\r\n        List<Transaction> invalidTransactions = new ArrayList<>();\r\n        for(Transaction t: currentTransactions){\r\n          log.info(\" transaction date : {}\",t.getCreationDate());\r\n          if(!wallets.containsKey(t.getFromHexHash())){\r\n            try{\r\n            \tWallet originWallet = crossStorageApi.find(defaultRepo,t.getFromHexHash(), Wallet.class);\r\n                log.info(\"add originWallet:{} {} to map\",originWallet.getUuid(),originWallet.getBalance());\r\n                wallets.put(t.getFromHexHash(),originWallet);\r\n            } catch(Exception e){\r\n              log.info(\" cannot find origin wallet, set blockNumber to INVALID\");\r\n              t.setBlockNumber(\"INVALID\");\r\n              try {\r\n              crossStorageApi.createOrUpdate(defaultRepo, t);\r\n              } catch(Exception ex){\r\n                ex.printStackTrace();\r\n              }\r\n              invalidTransactions.add(t);\r\n            }\r\n          }\r\n          if(t.getBlockNumber() == null){\r\n            Wallet originWallet = wallets.get(t.getFromHexHash());\r\n          \tlog.info(\"originWallet 0x{} old balance:{}\",t.getFromHexHash(),originWallet.getBalance());\r\n            BigInteger transacValue = new BigInteger(t.getValue());\r\n          \tif(new BigInteger(originWallet.getBalance()).compareTo(transacValue)>=0){\r\n                originWallet.setBalance(\"\"+new BigInteger(originWallet.getBalance()).add(transacValue.negate()));\r\n                try{\r\n            \t\tWallet destinationWallet = crossStorageApi.find(defaultRepo,t.getToHexHash(), Wallet.class);\r\n          \t\t\tlog.info(\"destinationWallet 0x{} old balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\r\n                    destinationWallet.setBalance(\"\"+new BigInteger(destinationWallet.getBalance()).add(transacValue));\r\n          \t\t\tcrossStorageApi.createOrUpdate(defaultRepo, destinationWallet);\r\n          \t\t\tlog.info(\"destinationWallet 0x{} new balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\r\n          \t\t\ttransactionHashes+=t.getHexHash();\r\n                } catch(Exception e){\r\n              \t\tlog.info(\" cannot find destination wallet, set blockNumber to INVALID\");\r\n              \t\tt.setBlockNumber(\"INVALID\");\r\n              \t\ttry{\r\n\t\t\t\t\t\tcrossStorageApi.createOrUpdate(defaultRepo, t);\r\n                    } catch(Exception ex){\r\n                \t\tex.printStackTrace();\r\n              \t\t}\r\n              \t\tinvalidTransactions.add(t);\r\n                }\r\n          \t} else {\r\n              log.info(\"insufficient balance, set blockNumber to INVALID\");\r\n              t.setBlockNumber(\"INVALID\");\r\n              try{\r\n              \tcrossStorageApi.createOrUpdate(defaultRepo, t);\r\n              } catch(Exception ex){\r\n                ex.printStackTrace();\r\n              }\r\n              invalidTransactions.add(t);\r\n            }\r\n          }\r\n        }\r\n        currentTransactions.removeAll(invalidTransactions);\r\n        Block block =  new Block();\r\n        block.setCreationDate(Instant.now());\r\n        \r\n        //FIXME parent should not be null\r\n        block.setParentHash(parentBlock==null?\"\":parentBlock.getHash());\r\n        block.setSize((long)currentTransactions.size());\r\n        \r\n        //FIXME hash parent hash\r\n        block.setHash(Hash.sha3(transactionHashes).substring(2));\r\n        \r\n        block.setBlockNumber(blockHeight);\r\n        try{\r\n          crossStorageApi.createOrUpdate(defaultRepo, block);\r\n          long i=0;\r\n          for(Transaction t: currentTransactions){\r\n              Wallet originWallet = wallets.get(t.getFromHexHash());\r\n              log.info(\"originWallet 0x{} new balance:{}\",t.getFromHexHash(),originWallet.getBalance());\r\n              crossStorageApi.createOrUpdate(defaultRepo, originWallet);\r\n              t.setBlockHash(block.getHash());\r\n              t.setBlockNumber(\"\"+block.getBlockNumber());\r\n              t.setTransactionIndex(i++);\r\n              crossStorageApi.createOrUpdate(defaultRepo, t);\r\n          }\r\n\r\n          parentBlock=block;\r\n          currentTransactions = nextTransactions;\r\n          nextTransactions = new ArrayList<>();\r\n        } catch(Exception ex){\r\n            ex.printStackTrace();\r\n        }\r\n        \r\n        isForging.set(false);\r\n      }\r\n    }\r\n  \r\n}\r\n",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ {
      "groupId" : "org.web3j",
      "artifactId" : "crypto",
      "version" : "4.8.9",
      "coordinates" : "org.web3j:crypto:4.8.9"
    } ],
    "importScriptInstances" : [ ]
  }, {
    "code" : "io.liquichain.api.rpc.BlockchainProcessor",
    "inputs" : [ ],
    "outputs" : [ {
      "name" : "result",
      "type" : "String"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package io.liquichain.api.rpc;\r\n\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.meveo.api.exception.EntityDoesNotExistsException;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.commons.utils.ParamBean;\r\nimport org.meveo.commons.utils.ParamBeanFactory;\r\nimport org.meveo.model.customEntities.VerifiedEmail;\r\nimport org.meveo.model.customEntities.VerifiedPhoneNumber;\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport java.math.BigInteger;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nimport org.web3j.crypto.*;\r\nimport org.web3j.utils.*;\r\n\r\nimport static io.liquichain.api.rpc.EthApiConstants.*;\r\n\r\npublic class BlockchainProcessor extends Script {\r\n    private static final Logger LOG = LoggerFactory.getLogger(BlockchainProcessor.class);\r\n    private static final Map<String, Object[]> TRANSACTION_HOOKS = new HashMap<>();\r\n\r\n    private final RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private ParamBeanFactory paramBeanFactory = getCDIBean(ParamBeanFactory.class);\r\n\r\n    protected final CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    protected final Repository defaultRepo = repositoryService.findDefaultRepository();\r\n    protected ParamBean config = paramBeanFactory.getInstance();\r\n\r\n    protected String result;\r\n\r\n    public String getResult() {\r\n        return this.result;\r\n    }\r\n\r\n    public static boolean addTransactionHook(String regex, Script script) {\r\n        boolean isHookAdded = true;\r\n        String key = regex + \":\" + script.getClass().getName();\r\n        LOG.info(\"addTransactionHook key: {}\", key);\r\n        isHookAdded = !TRANSACTION_HOOKS.containsKey(key);\r\n        if (isHookAdded) {\r\n            Pattern pattern = Pattern.compile(regex);\r\n            TRANSACTION_HOOKS.put(key, new Object[]{pattern, script});\r\n        }\r\n        return isHookAdded;\r\n    }\r\n\r\n    protected void processTransactionHooks(String transactionHash, SignedRawTransaction transaction) {\r\n        try {\r\n            String data = new String(new BigInteger(transaction.getData(), 16).toByteArray());\r\n            LOG.info(\"try matching {} hooks\", TRANSACTION_HOOKS.size());\r\n            TRANSACTION_HOOKS.forEach((String key, Object[] hook) -> {\r\n                LOG.info(\"try hook {} on {}\", key, data);\r\n                Pattern pattern = (Pattern) hook[0];\r\n                Script script = (Script) hook[1];\r\n                Matcher matcher = pattern.matcher(data);\r\n                if (matcher.find()) {\r\n                    LOG.info(\" hook {} matched\", key);\r\n                    Map<String, Object> context = new HashMap<>();\r\n                    context.put(\"transaction\", transaction);\r\n                    context.put(\"transactionHash\", transactionHash);\r\n                    context.put(\"matcher\", matcher);\r\n                    try {\r\n                        script.execute(context);\r\n                        if (context.containsKey(\"result\")) {\r\n                            LOG.info(\" hook result:{} \", context.get(\"result\"));\r\n                        }\r\n                    } catch (Exception e) {\r\n                        LOG.error(\"error while invoking transaction hook {}\", script, e);\r\n                    }\r\n                } else {\r\n                    LOG.info(\" hook {} matched\", key);\r\n                }\r\n            });\r\n            if (data.contains(\"orderId\")) {\r\n                LOG.info(\"detected orderId:{}\", data);\r\n            }\r\n        } catch (Exception ex) {\r\n            LOG.info(\"error while detecting order:{}\", ex);\r\n        }\r\n    }\r\n\r\n    protected String createResponse(String requestId, String response) {\r\n        return EthApiUtils.createResponse(requestId, response);\r\n    }\r\n\r\n    protected String createErrorResponse(String requestId, String errorCode, String message) {\r\n        return EthApiUtils.createErrorResponse(requestId, errorCode, message);\r\n    }\r\n\r\n    protected String normalizeHash(String hash) {\r\n        return EthApiUtils.normalizeHash(hash);\r\n    }\r\n\r\n    protected String retrieveHash(List<String> parameters, int parameterIndex) {\r\n        return normalizeHash(parameters.get(parameterIndex));\r\n    }\r\n\r\n    protected boolean isJSONValid(String json) {\r\n        return EthApiUtils.isJSONValid(json);\r\n    }\r\n\r\n    protected String toHex(byte[] bytes) {\r\n        return EthApiUtils.toHex(bytes);\r\n    }\r\n\r\n    protected String toBigHex(String value) {\r\n        return EthApiUtils.toBigHex(value);\r\n    }\r\n\r\n    protected String validateName(String name) throws BusinessException {\r\n        if (name == null || name.trim().isEmpty()) {\r\n            throw new BusinessException(NAME_REQUIRED_ERROR);\r\n        }\r\n        Wallet walletWithSameName = null;\r\n        try {\r\n            walletWithSameName = crossStorageApi\r\n                    .find(defaultRepo, Wallet.class)\r\n                    .by(\"name\", name)\r\n                    .getResult();\r\n        } catch (Exception e) {\r\n            // do nothing, we want wallet name to be unique\r\n        }\r\n        if (walletWithSameName != null) {\r\n            String error = String.format(NAME_EXISTS_ERROR, name);\r\n            LOG.error(error);\r\n            throw new BusinessException(error);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected String validateEmail(String email, String walletId) throws BusinessException {\r\n        // if (email == null || email.trim().isEmpty()) {\r\n        // throw new BusinessException(EMAIL_REQUIRED_ERROR);\r\n        // }\r\n        if (email != null && !email.trim().isEmpty()) {\r\n            VerifiedEmail existingEmail = null;\r\n            try {\r\n                existingEmail = crossStorageApi\r\n                        .find(defaultRepo, VerifiedEmail.class)\r\n                        .by(\"email\", email)\r\n                        .by(\"not-inList walletId\", Arrays.asList(walletId))\r\n                        .getResult();\r\n            } catch (Exception e) {\r\n                // do nothing, we want email address to be unique\r\n            }\r\n            if (existingEmail != null) {\r\n                String error = String.format(EMAIL_EXISTS_ERROR, email);\r\n                LOG.error(error);\r\n                throw new BusinessException(error);\r\n            }\r\n        }\r\n        return email;\r\n    }\r\n\r\n    protected String validatePhoneNumber(String phoneNumber, String walletId)\r\n            throws BusinessException {\r\n        if (phoneNumber == null || phoneNumber.trim().isEmpty()) {\r\n            throw new BusinessException(PHONE_NUMBER_REQUIRED_ERROR);\r\n        }\r\n        VerifiedPhoneNumber existingPhoneNumber = null;\r\n        try {\r\n            existingPhoneNumber = crossStorageApi\r\n                    .find(defaultRepo, VerifiedPhoneNumber.class)\r\n                    .by(\"phoneNumber\", phoneNumber)\r\n                    .by(\"not-inList walletId\", Arrays.asList(walletId))\r\n                    .getResult();\r\n        } catch (Exception e) {\r\n            // do nothing, we want wallet phoneNumber to be unique\r\n        }\r\n        if (existingPhoneNumber != null) {\r\n            String error = String.format(PHONE_NUMBER_EXISTS_ERROR, phoneNumber);\r\n            LOG.error(error);\r\n            throw new BusinessException(error);\r\n        }\r\n        return phoneNumber;\r\n    }\r\n\r\n    protected String parseAddress(String signature, String message) throws Exception {\r\n        byte[] messageHash = Hash.sha3(message.getBytes(StandardCharsets.UTF_8));\r\n        LOG.info(\"messageHash={}\", Numeric.toHexString(messageHash));\r\n        String r = signature.substring(0, 66);\r\n        String s = \"0x\" + signature.substring(66, 130);\r\n        String v = \"0x\" + signature.substring(130, 132);\r\n        String publicKey = Sign\r\n                .signedMessageHashToKey(\r\n                        messageHash,\r\n                        new Sign.SignatureData(\r\n                                Numeric.hexStringToByteArray(v)[0],\r\n                                Numeric.hexStringToByteArray(r),\r\n                                Numeric.hexStringToByteArray(s)\r\n                        )\r\n                )\r\n                .toString(16);\r\n        String address = Keys.getAddress(publicKey);\r\n        LOG.info(\"address: \" + address);\r\n        return address;\r\n    }\r\n\r\n    protected <T> T findEntity(String uuid, Class<T> clazz) {\r\n        T entity = null;\r\n        try {\r\n            entity = crossStorageApi.find(defaultRepo, uuid, clazz);\r\n        } catch (EntityDoesNotExistsException e) {\r\n            LOG.warn(\"No {} with uuid: {}\", clazz.getSimpleName(), uuid);\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ ],
    "importScriptInstances" : [ ]
  } ]
}