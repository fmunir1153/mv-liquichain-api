{
  "code" : "io.liquichain.api.rpc.EthApiScript",
  "description" : "eth rpc api",
  "inputs" : [ ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.rpc;\n\nimport static io.liquichain.api.rpc.EthApiConstants.*;\n\nimport java.util.Map;\n\nimport org.meveo.admin.exception.BusinessException;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.liquichain.api.rpc.BlockchainProcessor;\n\npublic class EthApiScript extends BlockchainProcessor {\n    private static final Logger LOG = LoggerFactory.getLogger(EthApiScript.class);\n\n    private String blockchainType = config.getProperty(\"txn.blockchain.type\", \"DATABASE\");\n    private BLOCKCHAIN_TYPE BLOCKCHAIN_BACKEND = BLOCKCHAIN_TYPE.valueOf(blockchainType);\n\n    @Override\n    public void execute(Map<String, Object> parameters) throws BusinessException {\n        String method = \"\" + parameters.get(\"method\");\n        BlockchainProcessor processor = null;\n        if (WalletProcessor.WALLET_METHODS.contains(method)) {\n            processor = new WalletProcessor();\n        } else {\n            switch (BLOCKCHAIN_BACKEND) {\n                case BESU:\n                    processor = new BesuProcessor();\n                    break;\n                case FABRIC:\n                    break;\n                case SMART_CONTRACT:\n                    break;\n                case BESU_DB:\n                    break;\n                case DATABASE:\n                default:\n                    processor = new DatabaseProcessor();\n            }\n        }\n        if (processor != null) {\n            processor.execute(parameters);\n            result = processor.getResult();\n        } else {\n            LOG.info(\"json rpc: {}, parameters:{}\", method, parameters);\n            String requestId = \"\" + parameters.get(\"id\");\n            result = createErrorResponse(requestId, INVALID_REQUEST, NOT_IMPLEMENTED_ERROR);\n        }\n    }\n}\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ {
    "groupId" : "org.web3j",
    "artifactId" : "crypto",
    "version" : "4.8.9",
    "coordinates" : "org.web3j:crypto:4.8.9"
  } ],
  "importScriptInstances" : [ {
    "code" : "io.liquichain.api.rpc.BlockchainProcessor",
    "inputs" : [ ],
    "outputs" : [ {
      "name" : "result",
      "type" : "String"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package io.liquichain.api.rpc;\r\n\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.meveo.api.exception.EntityDoesNotExistsException;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.commons.utils.ParamBean;\r\nimport org.meveo.commons.utils.ParamBeanFactory;\r\nimport org.meveo.model.customEntities.VerifiedEmail;\r\nimport org.meveo.model.customEntities.VerifiedPhoneNumber;\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport java.math.BigInteger;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nimport org.web3j.crypto.*;\r\nimport org.web3j.utils.*;\r\n\r\nimport static io.liquichain.api.rpc.EthApiConstants.*;\r\n\r\npublic class BlockchainProcessor extends Script {\r\n    private static final Logger LOG = LoggerFactory.getLogger(BlockchainProcessor.class);\r\n    private static final Map<String, Object[]> TRANSACTION_HOOKS = new HashMap<>();\r\n\r\n    private final RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private ParamBeanFactory paramBeanFactory = getCDIBean(ParamBeanFactory.class);\r\n\r\n    protected final CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    protected final Repository defaultRepo = repositoryService.findDefaultRepository();\r\n    protected ParamBean config = paramBeanFactory.getInstance();\r\n\r\n    protected String result;\r\n\r\n    public String getResult() {\r\n        return this.result;\r\n    }\r\n\r\n    public static boolean addTransactionHook(String regex, Script script) {\r\n        boolean isHookAdded = true;\r\n        String key = regex + \":\" + script.getClass().getName();\r\n        LOG.info(\"addTransactionHook key: {}\", key);\r\n        isHookAdded = !TRANSACTION_HOOKS.containsKey(key);\r\n        if (isHookAdded) {\r\n            Pattern pattern = Pattern.compile(regex);\r\n            TRANSACTION_HOOKS.put(key, new Object[]{pattern, script});\r\n        }\r\n        return isHookAdded;\r\n    }\r\n\r\n    protected void processTransactionHooks(String transactionHash, SignedRawTransaction transaction) {\r\n        try {\r\n            String data = new String(new BigInteger(transaction.getData(), 16).toByteArray());\r\n            LOG.info(\"try matching {} hooks\", TRANSACTION_HOOKS.size());\r\n            TRANSACTION_HOOKS.forEach((String key, Object[] hook) -> {\r\n                LOG.info(\"try hook {} on {}\", key, data);\r\n                Pattern pattern = (Pattern) hook[0];\r\n                Script script = (Script) hook[1];\r\n                Matcher matcher = pattern.matcher(data);\r\n                if (matcher.find()) {\r\n                    LOG.info(\" hook {} matched\", key);\r\n                    Map<String, Object> context = new HashMap<>();\r\n                    context.put(\"transaction\", transaction);\r\n                    context.put(\"transactionHash\", transactionHash);\r\n                    context.put(\"matcher\", matcher);\r\n                    try {\r\n                        script.execute(context);\r\n                        if (context.containsKey(\"result\")) {\r\n                            LOG.info(\" hook result:{} \", context.get(\"result\"));\r\n                        }\r\n                    } catch (Exception e) {\r\n                        LOG.error(\"error while invoking transaction hook {}\", script, e);\r\n                    }\r\n                } else {\r\n                    LOG.info(\" hook {} matched\", key);\r\n                }\r\n            });\r\n            if (data.contains(\"orderId\")) {\r\n                LOG.info(\"detected orderId:{}\", data);\r\n            }\r\n        } catch (Exception ex) {\r\n            LOG.info(\"error while detecting order:{}\", ex);\r\n        }\r\n    }\r\n\r\n    protected String createResponse(String requestId, String response) {\r\n        return EthApiUtils.createResponse(requestId, response);\r\n    }\r\n\r\n    protected String createErrorResponse(String requestId, String errorCode, String message) {\r\n        return EthApiUtils.createErrorResponse(requestId, errorCode, message);\r\n    }\r\n\r\n    protected String normalizeHash(String hash) {\r\n        return EthApiUtils.normalizeHash(hash);\r\n    }\r\n\r\n    protected String retrieveHash(List<String> parameters, int parameterIndex) {\r\n        return normalizeHash(parameters.get(parameterIndex));\r\n    }\r\n\r\n    protected boolean isJSONValid(String json) {\r\n        return EthApiUtils.isJSONValid(json);\r\n    }\r\n\r\n    protected String toHex(byte[] bytes) {\r\n        return EthApiUtils.toHex(bytes);\r\n    }\r\n\r\n    protected String toBigHex(String value) {\r\n        return EthApiUtils.toBigHex(value);\r\n    }\r\n\r\n    protected String validateName(String name) throws BusinessException {\r\n        if (name == null || name.trim().isEmpty()) {\r\n            throw new BusinessException(NAME_REQUIRED_ERROR);\r\n        }\r\n        Wallet walletWithSameName = null;\r\n        try {\r\n            walletWithSameName = crossStorageApi\r\n                    .find(defaultRepo, Wallet.class)\r\n                    .by(\"name\", name)\r\n                    .getResult();\r\n        } catch (Exception e) {\r\n            // do nothing, we want wallet name to be unique\r\n        }\r\n        if (walletWithSameName != null) {\r\n            String error = String.format(NAME_EXISTS_ERROR, name);\r\n            LOG.error(error);\r\n            throw new BusinessException(error);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected String validateEmail(String email, String walletId) throws BusinessException {\r\n        // if (email == null || email.trim().isEmpty()) {\r\n        // throw new BusinessException(EMAIL_REQUIRED_ERROR);\r\n        // }\r\n        if (email != null && !email.trim().isEmpty()) {\r\n            VerifiedEmail existingEmail = null;\r\n            try {\r\n                existingEmail = crossStorageApi\r\n                        .find(defaultRepo, VerifiedEmail.class)\r\n                        .by(\"email\", email)\r\n                        .by(\"not-inList walletId\", Arrays.asList(walletId))\r\n                        .getResult();\r\n            } catch (Exception e) {\r\n                // do nothing, we want email address to be unique\r\n            }\r\n            if (existingEmail != null) {\r\n                String error = String.format(EMAIL_EXISTS_ERROR, email);\r\n                LOG.error(error);\r\n                throw new BusinessException(error);\r\n            }\r\n        }\r\n        return email;\r\n    }\r\n\r\n    protected String validatePhoneNumber(String phoneNumber, String walletId)\r\n            throws BusinessException {\r\n        if (phoneNumber == null || phoneNumber.trim().isEmpty()) {\r\n            throw new BusinessException(PHONE_NUMBER_REQUIRED_ERROR);\r\n        }\r\n        VerifiedPhoneNumber existingPhoneNumber = null;\r\n        try {\r\n            existingPhoneNumber = crossStorageApi\r\n                    .find(defaultRepo, VerifiedPhoneNumber.class)\r\n                    .by(\"phoneNumber\", phoneNumber)\r\n                    .by(\"not-inList walletId\", Arrays.asList(walletId))\r\n                    .getResult();\r\n        } catch (Exception e) {\r\n            // do nothing, we want wallet phoneNumber to be unique\r\n        }\r\n        if (existingPhoneNumber != null) {\r\n            String error = String.format(PHONE_NUMBER_EXISTS_ERROR, phoneNumber);\r\n            LOG.error(error);\r\n            throw new BusinessException(error);\r\n        }\r\n        return phoneNumber;\r\n    }\r\n\r\n    protected String parseAddress(String signature, String message) throws Exception {\r\n        byte[] messageHash = Hash.sha3(message.getBytes(StandardCharsets.UTF_8));\r\n        LOG.info(\"messageHash={}\", Numeric.toHexString(messageHash));\r\n        String r = signature.substring(0, 66);\r\n        String s = \"0x\" + signature.substring(66, 130);\r\n        String v = \"0x\" + signature.substring(130, 132);\r\n        String publicKey = Sign\r\n                .signedMessageHashToKey(\r\n                        messageHash,\r\n                        new Sign.SignatureData(\r\n                                Numeric.hexStringToByteArray(v)[0],\r\n                                Numeric.hexStringToByteArray(r),\r\n                                Numeric.hexStringToByteArray(s)\r\n                        )\r\n                )\r\n                .toString(16);\r\n        String address = Keys.getAddress(publicKey);\r\n        LOG.info(\"address: \" + address);\r\n        return address;\r\n    }\r\n\r\n    protected <T> T findEntity(String uuid, Class<T> clazz) {\r\n        T entity = null;\r\n        try {\r\n            entity = crossStorageApi.find(defaultRepo, uuid, clazz);\r\n        } catch (EntityDoesNotExistsException e) {\r\n            LOG.warn(\"No {} with uuid: {}\", clazz.getSimpleName(), uuid);\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ ],
    "importScriptInstances" : [ ]
  } ]
}